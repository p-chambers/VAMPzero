
#
# Generated Mon May 26 14:26:07 2014 by generateDS.py version 2.12d.
#
# Command line options:
#   ('-o', 'freemindSchema.py')
#
# Command line arguments:
#   freemind.xsd
#
# Command line:
#   generateDS.py -o "freemindSchema.py" freemind.xsd
#
# Current working directory (os.getcwd()):
#   generateDS-2.12d
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False

(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:

        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:

            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:

            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:

            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:

            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (

                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (

                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (

                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class Parameters(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, XML_STORAGE_TILE_SOURCE=None, XML_STORAGE_ZOOM=None, CLONE_ID=None, XML_STORAGE_POS_LAT=None, CLONE_IDS=None, XML_STORAGE_MAP_LON=None, XML_STORAGE_MAP_TOOLTIP_LOCATION=None, REMINDUSERAT=None, XML_STORAGE_MAP_LAT=None, ORIGINAL_ID=None, XML_STORAGE_POS_LON=None, CLONE_ITSELF=None):
        self.original_tagname_ = None
        self.XML_STORAGE_TILE_SOURCE = _cast(None, XML_STORAGE_TILE_SOURCE)
        self.XML_STORAGE_ZOOM = _cast(None, XML_STORAGE_ZOOM)
        self.CLONE_ID = _cast(None, CLONE_ID)
        self.XML_STORAGE_POS_LAT = _cast(None, XML_STORAGE_POS_LAT)
        self.CLONE_IDS = _cast(None, CLONE_IDS)
        self.XML_STORAGE_MAP_LON = _cast(None, XML_STORAGE_MAP_LON)
        self.XML_STORAGE_MAP_TOOLTIP_LOCATION = _cast(None, XML_STORAGE_MAP_TOOLTIP_LOCATION)
        self.REMINDUSERAT = _cast(int, REMINDUSERAT)

        self.XML_STORAGE_MAP_LAT = _cast(None, XML_STORAGE_MAP_LAT)
        self.ORIGINAL_ID = _cast(None, ORIGINAL_ID)
        self.XML_STORAGE_POS_LON = _cast(None, XML_STORAGE_POS_LON)
        self.CLONE_ITSELF = _cast(None, CLONE_ITSELF)
    def factory(*args_, **kwargs_):
        if Parameters.subclass:
            return Parameters.subclass(*args_, **kwargs_)
        else:
            return Parameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_XML_STORAGE_TILE_SOURCE(self): return self.XML_STORAGE_TILE_SOURCE
    def set_XML_STORAGE_TILE_SOURCE(self, XML_STORAGE_TILE_SOURCE): self.XML_STORAGE_TILE_SOURCE = XML_STORAGE_TILE_SOURCE
    def get_XML_STORAGE_ZOOM(self): return self.XML_STORAGE_ZOOM
    def set_XML_STORAGE_ZOOM(self, XML_STORAGE_ZOOM): self.XML_STORAGE_ZOOM = XML_STORAGE_ZOOM
    def get_CLONE_ID(self): return self.CLONE_ID
    def set_CLONE_ID(self, CLONE_ID): self.CLONE_ID = CLONE_ID
    def get_XML_STORAGE_POS_LAT(self): return self.XML_STORAGE_POS_LAT
    def set_XML_STORAGE_POS_LAT(self, XML_STORAGE_POS_LAT): self.XML_STORAGE_POS_LAT = XML_STORAGE_POS_LAT
    def get_CLONE_IDS(self): return self.CLONE_IDS
    def set_CLONE_IDS(self, CLONE_IDS): self.CLONE_IDS = CLONE_IDS
    def get_XML_STORAGE_MAP_LON(self): return self.XML_STORAGE_MAP_LON
    def set_XML_STORAGE_MAP_LON(self, XML_STORAGE_MAP_LON): self.XML_STORAGE_MAP_LON = XML_STORAGE_MAP_LON
    def get_XML_STORAGE_MAP_TOOLTIP_LOCATION(self): return self.XML_STORAGE_MAP_TOOLTIP_LOCATION
    def set_XML_STORAGE_MAP_TOOLTIP_LOCATION(self, XML_STORAGE_MAP_TOOLTIP_LOCATION): self.XML_STORAGE_MAP_TOOLTIP_LOCATION = XML_STORAGE_MAP_TOOLTIP_LOCATION
    def get_REMINDUSERAT(self): return self.REMINDUSERAT
    def set_REMINDUSERAT(self, REMINDUSERAT): self.REMINDUSERAT = REMINDUSERAT
    def get_XML_STORAGE_MAP_LAT(self): return self.XML_STORAGE_MAP_LAT
















    def set_XML_STORAGE_MAP_LAT(self, XML_STORAGE_MAP_LAT): self.XML_STORAGE_MAP_LAT = XML_STORAGE_MAP_LAT
    def get_ORIGINAL_ID(self): return self.ORIGINAL_ID
    def set_ORIGINAL_ID(self, ORIGINAL_ID): self.ORIGINAL_ID = ORIGINAL_ID
    def get_XML_STORAGE_POS_LON(self): return self.XML_STORAGE_POS_LON
    def set_XML_STORAGE_POS_LON(self, XML_STORAGE_POS_LON): self.XML_STORAGE_POS_LON = XML_STORAGE_POS_LON
    def get_CLONE_ITSELF(self): return self.CLONE_ITSELF
    def set_CLONE_ITSELF(self, CLONE_ITSELF): self.CLONE_ITSELF = CLONE_ITSELF
    def hasContent_(self):
        if (


        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Parameters', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Parameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Parameters', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Parameters'):
        if self.XML_STORAGE_TILE_SOURCE is not None and 'XML_STORAGE_TILE_SOURCE' not in already_processed:
            already_processed.add('XML_STORAGE_TILE_SOURCE')
            outfile.write(' XML_STORAGE_TILE_SOURCE=%s' % (self.gds_format_string(quote_attrib(self.XML_STORAGE_TILE_SOURCE).encode(ExternalEncoding), input_name='XML_STORAGE_TILE_SOURCE'), ))
        if self.XML_STORAGE_ZOOM is not None and 'XML_STORAGE_ZOOM' not in already_processed:
            already_processed.add('XML_STORAGE_ZOOM')
            outfile.write(' XML_STORAGE_ZOOM=%s' % (self.gds_format_string(quote_attrib(self.XML_STORAGE_ZOOM).encode(ExternalEncoding), input_name='XML_STORAGE_ZOOM'), ))
        if self.CLONE_ID is not None and 'CLONE_ID' not in already_processed:
            already_processed.add('CLONE_ID')
            outfile.write(' CLONE_ID=%s' % (self.gds_format_string(quote_attrib(self.CLONE_ID).encode(ExternalEncoding), input_name='CLONE_ID'), ))
        if self.XML_STORAGE_POS_LAT is not None and 'XML_STORAGE_POS_LAT' not in already_processed:
            already_processed.add('XML_STORAGE_POS_LAT')
            outfile.write(' XML_STORAGE_POS_LAT=%s' % (self.gds_format_string(quote_attrib(self.XML_STORAGE_POS_LAT).encode(ExternalEncoding), input_name='XML_STORAGE_POS_LAT'), ))
        if self.CLONE_IDS is not None and 'CLONE_IDS' not in already_processed:
            already_processed.add('CLONE_IDS')
            outfile.write(' CLONE_IDS=%s' % (self.gds_format_string(quote_attrib(self.CLONE_IDS).encode(ExternalEncoding), input_name='CLONE_IDS'), ))
        if self.XML_STORAGE_MAP_LON is not None and 'XML_STORAGE_MAP_LON' not in already_processed:
            already_processed.add('XML_STORAGE_MAP_LON')
            outfile.write(' XML_STORAGE_MAP_LON=%s' % (self.gds_format_string(quote_attrib(self.XML_STORAGE_MAP_LON).encode(ExternalEncoding), input_name='XML_STORAGE_MAP_LON'), ))
        if self.XML_STORAGE_MAP_TOOLTIP_LOCATION is not None and 'XML_STORAGE_MAP_TOOLTIP_LOCATION' not in already_processed:
            already_processed.add('XML_STORAGE_MAP_TOOLTIP_LOCATION')
            outfile.write(' XML_STORAGE_MAP_TOOLTIP_LOCATION=%s' % (self.gds_format_string(quote_attrib(self.XML_STORAGE_MAP_TOOLTIP_LOCATION).encode(ExternalEncoding), input_name='XML_STORAGE_MAP_TOOLTIP_LOCATION'), ))
        if self.REMINDUSERAT is not None and 'REMINDUSERAT' not in already_processed:
            already_processed.add('REMINDUSERAT')
            outfile.write(' REMINDUSERAT="%s"' % self.gds_format_integer(self.REMINDUSERAT, input_name='REMINDUSERAT'))
        if self.XML_STORAGE_MAP_LAT is not None and 'XML_STORAGE_MAP_LAT' not in already_processed:
            already_processed.add('XML_STORAGE_MAP_LAT')
            outfile.write(' XML_STORAGE_MAP_LAT=%s' % (self.gds_format_string(quote_attrib(self.XML_STORAGE_MAP_LAT).encode(ExternalEncoding), input_name='XML_STORAGE_MAP_LAT'), ))
        if self.ORIGINAL_ID is not None and 'ORIGINAL_ID' not in already_processed:
            already_processed.add('ORIGINAL_ID')
            outfile.write(' ORIGINAL_ID=%s' % (self.gds_format_string(quote_attrib(self.ORIGINAL_ID).encode(ExternalEncoding), input_name='ORIGINAL_ID'), ))
        if self.XML_STORAGE_POS_LON is not None and 'XML_STORAGE_POS_LON' not in already_processed:
            already_processed.add('XML_STORAGE_POS_LON')
            outfile.write(' XML_STORAGE_POS_LON=%s' % (self.gds_format_string(quote_attrib(self.XML_STORAGE_POS_LON).encode(ExternalEncoding), input_name='XML_STORAGE_POS_LON'), ))
        if self.CLONE_ITSELF is not None and 'CLONE_ITSELF' not in already_processed:
            already_processed.add('CLONE_ITSELF')
            outfile.write(' CLONE_ITSELF=%s' % (self.gds_format_string(quote_attrib(self.CLONE_ITSELF).encode(ExternalEncoding), input_name='CLONE_ITSELF'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Parameters', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Parameters'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.XML_STORAGE_TILE_SOURCE is not None and 'XML_STORAGE_TILE_SOURCE' not in already_processed:
            already_processed.add('XML_STORAGE_TILE_SOURCE')
            showIndent(outfile, level)
            outfile.write('XML_STORAGE_TILE_SOURCE="%s",\n' % (self.XML_STORAGE_TILE_SOURCE,))
        if self.XML_STORAGE_ZOOM is not None and 'XML_STORAGE_ZOOM' not in already_processed:
            already_processed.add('XML_STORAGE_ZOOM')
            showIndent(outfile, level)
            outfile.write('XML_STORAGE_ZOOM="%s",\n' % (self.XML_STORAGE_ZOOM,))
        if self.CLONE_ID is not None and 'CLONE_ID' not in already_processed:
            already_processed.add('CLONE_ID')
            showIndent(outfile, level)
            outfile.write('CLONE_ID="%s",\n' % (self.CLONE_ID,))
        if self.XML_STORAGE_POS_LAT is not None and 'XML_STORAGE_POS_LAT' not in already_processed:
            already_processed.add('XML_STORAGE_POS_LAT')
            showIndent(outfile, level)
            outfile.write('XML_STORAGE_POS_LAT="%s",\n' % (self.XML_STORAGE_POS_LAT,))
        if self.CLONE_IDS is not None and 'CLONE_IDS' not in already_processed:
            already_processed.add('CLONE_IDS')
            showIndent(outfile, level)
            outfile.write('CLONE_IDS="%s",\n' % (self.CLONE_IDS,))
        if self.XML_STORAGE_MAP_LON is not None and 'XML_STORAGE_MAP_LON' not in already_processed:
            already_processed.add('XML_STORAGE_MAP_LON')
            showIndent(outfile, level)
            outfile.write('XML_STORAGE_MAP_LON="%s",\n' % (self.XML_STORAGE_MAP_LON,))
        if self.XML_STORAGE_MAP_TOOLTIP_LOCATION is not None and 'XML_STORAGE_MAP_TOOLTIP_LOCATION' not in already_processed:
            already_processed.add('XML_STORAGE_MAP_TOOLTIP_LOCATION')
            showIndent(outfile, level)
            outfile.write('XML_STORAGE_MAP_TOOLTIP_LOCATION="%s",\n' % (self.XML_STORAGE_MAP_TOOLTIP_LOCATION,))
        if self.REMINDUSERAT is not None and 'REMINDUSERAT' not in already_processed:
            already_processed.add('REMINDUSERAT')
            showIndent(outfile, level)
            outfile.write('REMINDUSERAT=%d,\n' % (self.REMINDUSERAT,))

        if self.XML_STORAGE_MAP_LAT is not None and 'XML_STORAGE_MAP_LAT' not in already_processed:
            already_processed.add('XML_STORAGE_MAP_LAT')
            showIndent(outfile, level)
            outfile.write('XML_STORAGE_MAP_LAT="%s",\n' % (self.XML_STORAGE_MAP_LAT,))
        if self.ORIGINAL_ID is not None and 'ORIGINAL_ID' not in already_processed:
            already_processed.add('ORIGINAL_ID')
            showIndent(outfile, level)
            outfile.write('ORIGINAL_ID="%s",\n' % (self.ORIGINAL_ID,))
        if self.XML_STORAGE_POS_LON is not None and 'XML_STORAGE_POS_LON' not in already_processed:
            already_processed.add('XML_STORAGE_POS_LON')
            showIndent(outfile, level)
            outfile.write('XML_STORAGE_POS_LON="%s",\n' % (self.XML_STORAGE_POS_LON,))
        if self.CLONE_ITSELF is not None and 'CLONE_ITSELF' not in already_processed:
            already_processed.add('CLONE_ITSELF')
            showIndent(outfile, level)
            outfile.write('CLONE_ITSELF="%s",\n' % (self.CLONE_ITSELF,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)

        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):

        value = find_attr_value_('XML_STORAGE_TILE_SOURCE', node)
        if value is not None and 'XML_STORAGE_TILE_SOURCE' not in already_processed:
            already_processed.add('XML_STORAGE_TILE_SOURCE')
            self.XML_STORAGE_TILE_SOURCE = value
        value = find_attr_value_('XML_STORAGE_ZOOM', node)
        if value is not None and 'XML_STORAGE_ZOOM' not in already_processed:
            already_processed.add('XML_STORAGE_ZOOM')
            self.XML_STORAGE_ZOOM = value
        value = find_attr_value_('CLONE_ID', node)
        if value is not None and 'CLONE_ID' not in already_processed:
            already_processed.add('CLONE_ID')
            self.CLONE_ID = value
        value = find_attr_value_('XML_STORAGE_POS_LAT', node)
        if value is not None and 'XML_STORAGE_POS_LAT' not in already_processed:
            already_processed.add('XML_STORAGE_POS_LAT')
            self.XML_STORAGE_POS_LAT = value
        value = find_attr_value_('CLONE_IDS', node)
        if value is not None and 'CLONE_IDS' not in already_processed:
            already_processed.add('CLONE_IDS')
            self.CLONE_IDS = value
        value = find_attr_value_('XML_STORAGE_MAP_LON', node)
        if value is not None and 'XML_STORAGE_MAP_LON' not in already_processed:
            already_processed.add('XML_STORAGE_MAP_LON')
            self.XML_STORAGE_MAP_LON = value
        value = find_attr_value_('XML_STORAGE_MAP_TOOLTIP_LOCATION', node)
        if value is not None and 'XML_STORAGE_MAP_TOOLTIP_LOCATION' not in already_processed:
            already_processed.add('XML_STORAGE_MAP_TOOLTIP_LOCATION')
            self.XML_STORAGE_MAP_TOOLTIP_LOCATION = value
        value = find_attr_value_('REMINDUSERAT', node)
        if value is not None and 'REMINDUSERAT' not in already_processed:
            already_processed.add('REMINDUSERAT')
            try:
                self.REMINDUSERAT = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('XML_STORAGE_MAP_LAT', node)
        if value is not None and 'XML_STORAGE_MAP_LAT' not in already_processed:
            already_processed.add('XML_STORAGE_MAP_LAT')
            self.XML_STORAGE_MAP_LAT = value
        value = find_attr_value_('ORIGINAL_ID', node)
        if value is not None and 'ORIGINAL_ID' not in already_processed:
            already_processed.add('ORIGINAL_ID')
            self.ORIGINAL_ID = value
        value = find_attr_value_('XML_STORAGE_POS_LON', node)
        if value is not None and 'XML_STORAGE_POS_LON' not in already_processed:
            already_processed.add('XML_STORAGE_POS_LON')
            self.XML_STORAGE_POS_LON = value
        value = find_attr_value_('CLONE_ITSELF', node)
        if value is not None and 'CLONE_ITSELF' not in already_processed:
            already_processed.add('CLONE_ITSELF')
            self.CLONE_ITSELF = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Parameters


class text(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):

        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if text.subclass:
            return text.subclass(*args_, **kwargs_)
        else:
            return text(*args_, **kwargs_)
    factory = staticmethod(factory)
















    def hasContent_(self):
        if (


        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='text', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='text')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='text', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='text'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='text', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='text'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):


        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)

        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class text


class arrowlink(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, STARTINCLINATION=None, COLOR=None, ENDARROW=None, DESTINATION=None, STARTARROW=None, ID=None, ENDINCLINATION=None):
        self.original_tagname_ = None
        self.STARTINCLINATION = _cast(None, STARTINCLINATION)
        self.COLOR = _cast(None, COLOR)
        self.ENDARROW = _cast(None, ENDARROW)
        self.DESTINATION = _cast(None, DESTINATION)
        self.STARTARROW = _cast(None, STARTARROW)
        self.ID = _cast(None, ID)
        self.ENDINCLINATION = _cast(None, ENDINCLINATION)

    def factory(*args_, **kwargs_):
        if arrowlink.subclass:
            return arrowlink.subclass(*args_, **kwargs_)
        else:
            return arrowlink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_STARTINCLINATION(self): return self.STARTINCLINATION
    def set_STARTINCLINATION(self, STARTINCLINATION): self.STARTINCLINATION = STARTINCLINATION
    def get_COLOR(self): return self.COLOR
    def set_COLOR(self, COLOR): self.COLOR = COLOR
    def get_ENDARROW(self): return self.ENDARROW
    def set_ENDARROW(self, ENDARROW): self.ENDARROW = ENDARROW
    def get_DESTINATION(self): return self.DESTINATION
    def set_DESTINATION(self, DESTINATION): self.DESTINATION = DESTINATION
    def get_STARTARROW(self): return self.STARTARROW
    def set_STARTARROW(self, STARTARROW): self.STARTARROW = STARTARROW
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_ENDINCLINATION(self): return self.ENDINCLINATION
    def set_ENDINCLINATION(self, ENDINCLINATION): self.ENDINCLINATION = ENDINCLINATION


    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='arrowlink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='arrowlink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='arrowlink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='arrowlink'):
        if self.STARTINCLINATION is not None and 'STARTINCLINATION' not in already_processed:
            already_processed.add('STARTINCLINATION')
            outfile.write(' STARTINCLINATION=%s' % (self.gds_format_string(quote_attrib(self.STARTINCLINATION).encode(ExternalEncoding), input_name='STARTINCLINATION'), ))
        if self.COLOR is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            outfile.write(' COLOR=%s' % (self.gds_format_string(quote_attrib(self.COLOR).encode(ExternalEncoding), input_name='COLOR'), ))
        if self.ENDARROW is not None and 'ENDARROW' not in already_processed:
            already_processed.add('ENDARROW')
            outfile.write(' ENDARROW=%s' % (self.gds_format_string(quote_attrib(self.ENDARROW).encode(ExternalEncoding), input_name='ENDARROW'), ))
        if self.DESTINATION is not None and 'DESTINATION' not in already_processed:
            already_processed.add('DESTINATION')
            outfile.write(' DESTINATION=%s' % (self.gds_format_string(quote_attrib(self.DESTINATION).encode(ExternalEncoding), input_name='DESTINATION'), ))
        if self.STARTARROW is not None and 'STARTARROW' not in already_processed:
            already_processed.add('STARTARROW')
            outfile.write(' STARTARROW=%s' % (self.gds_format_string(quote_attrib(self.STARTARROW).encode(ExternalEncoding), input_name='STARTARROW'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.ENDINCLINATION is not None and 'ENDINCLINATION' not in already_processed:
            already_processed.add('ENDINCLINATION')
            outfile.write(' ENDINCLINATION=%s' % (self.gds_format_string(quote_attrib(self.ENDINCLINATION).encode(ExternalEncoding), input_name='ENDINCLINATION'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='arrowlink', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='arrowlink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.STARTINCLINATION is not None and 'STARTINCLINATION' not in already_processed:
            already_processed.add('STARTINCLINATION')
            showIndent(outfile, level)
            outfile.write('STARTINCLINATION="%s",\n' % (self.STARTINCLINATION,))
        if self.COLOR is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            showIndent(outfile, level)
            outfile.write('COLOR="%s",\n' % (self.COLOR,))
        if self.ENDARROW is not None and 'ENDARROW' not in already_processed:
            already_processed.add('ENDARROW')
            showIndent(outfile, level)
            outfile.write('ENDARROW="%s",\n' % (self.ENDARROW,))
        if self.DESTINATION is not None and 'DESTINATION' not in already_processed:
            already_processed.add('DESTINATION')
            showIndent(outfile, level)
            outfile.write('DESTINATION="%s",\n' % (self.DESTINATION,))
        if self.STARTARROW is not None and 'STARTARROW' not in already_processed:
            already_processed.add('STARTARROW')
            showIndent(outfile, level)
            outfile.write('STARTARROW="%s",\n' % (self.STARTARROW,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID="%s",\n' % (self.ID,))
        if self.ENDINCLINATION is not None and 'ENDINCLINATION' not in already_processed:
            already_processed.add('ENDINCLINATION')
            showIndent(outfile, level)
            outfile.write('ENDINCLINATION="%s",\n' % (self.ENDINCLINATION,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('STARTINCLINATION', node)
        if value is not None and 'STARTINCLINATION' not in already_processed:
            already_processed.add('STARTINCLINATION')
            self.STARTINCLINATION = value
        value = find_attr_value_('COLOR', node)
        if value is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            self.COLOR = value
        value = find_attr_value_('ENDARROW', node)
        if value is not None and 'ENDARROW' not in already_processed:
            already_processed.add('ENDARROW')
            self.ENDARROW = value
        value = find_attr_value_('DESTINATION', node)
        if value is not None and 'DESTINATION' not in already_processed:
            already_processed.add('DESTINATION')
            self.DESTINATION = value
        value = find_attr_value_('STARTARROW', node)
        if value is not None and 'STARTARROW' not in already_processed:
            already_processed.add('STARTARROW')
            self.STARTARROW = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('ENDINCLINATION', node)
        if value is not None and 'ENDINCLINATION' not in already_processed:
            already_processed.add('ENDINCLINATION')
            self.ENDINCLINATION = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class arrowlink


class linktarget(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, STARTINCLINATION=None, COLOR=None, ENDARROW=None, DESTINATION=None, SOURCE=None, STARTARROW=None, ID=None, ENDINCLINATION=None):
        self.original_tagname_ = None
        self.STARTINCLINATION = _cast(None, STARTINCLINATION)
        self.COLOR = _cast(None, COLOR)
        self.ENDARROW = _cast(None, ENDARROW)
        self.DESTINATION = _cast(None, DESTINATION)
        self.SOURCE = _cast(None, SOURCE)
        self.STARTARROW = _cast(None, STARTARROW)
        self.ID = _cast(None, ID)
        self.ENDINCLINATION = _cast(None, ENDINCLINATION)
    def factory(*args_, **kwargs_):
        if linktarget.subclass:
            return linktarget.subclass(*args_, **kwargs_)
        else:
            return linktarget(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_STARTINCLINATION(self): return self.STARTINCLINATION
    def set_STARTINCLINATION(self, STARTINCLINATION): self.STARTINCLINATION = STARTINCLINATION
    def get_COLOR(self): return self.COLOR
    def set_COLOR(self, COLOR): self.COLOR = COLOR
    def get_ENDARROW(self): return self.ENDARROW
    def set_ENDARROW(self, ENDARROW): self.ENDARROW = ENDARROW
    def get_DESTINATION(self): return self.DESTINATION
    def set_DESTINATION(self, DESTINATION): self.DESTINATION = DESTINATION
    def get_SOURCE(self): return self.SOURCE
    def set_SOURCE(self, SOURCE): self.SOURCE = SOURCE
    def get_STARTARROW(self): return self.STARTARROW
    def set_STARTARROW(self, STARTARROW): self.STARTARROW = STARTARROW
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_ENDINCLINATION(self): return self.ENDINCLINATION
    def set_ENDINCLINATION(self, ENDINCLINATION): self.ENDINCLINATION = ENDINCLINATION
    def hasContent_(self):
        if (


        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='linktarget', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='linktarget')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='linktarget', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='linktarget'):
        if self.STARTINCLINATION is not None and 'STARTINCLINATION' not in already_processed:
            already_processed.add('STARTINCLINATION')
            outfile.write(' STARTINCLINATION=%s' % (self.gds_format_string(quote_attrib(self.STARTINCLINATION).encode(ExternalEncoding), input_name='STARTINCLINATION'), ))
        if self.COLOR is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            outfile.write(' COLOR=%s' % (self.gds_format_string(quote_attrib(self.COLOR).encode(ExternalEncoding), input_name='COLOR'), ))
        if self.ENDARROW is not None and 'ENDARROW' not in already_processed:
            already_processed.add('ENDARROW')
            outfile.write(' ENDARROW=%s' % (self.gds_format_string(quote_attrib(self.ENDARROW).encode(ExternalEncoding), input_name='ENDARROW'), ))
        if self.DESTINATION is not None and 'DESTINATION' not in already_processed:
            already_processed.add('DESTINATION')
            outfile.write(' DESTINATION=%s' % (self.gds_format_string(quote_attrib(self.DESTINATION).encode(ExternalEncoding), input_name='DESTINATION'), ))
        if self.SOURCE is not None and 'SOURCE' not in already_processed:
            already_processed.add('SOURCE')
            outfile.write(' SOURCE=%s' % (self.gds_format_string(quote_attrib(self.SOURCE).encode(ExternalEncoding), input_name='SOURCE'), ))
        if self.STARTARROW is not None and 'STARTARROW' not in already_processed:
            already_processed.add('STARTARROW')
            outfile.write(' STARTARROW=%s' % (self.gds_format_string(quote_attrib(self.STARTARROW).encode(ExternalEncoding), input_name='STARTARROW'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.ENDINCLINATION is not None and 'ENDINCLINATION' not in already_processed:
            already_processed.add('ENDINCLINATION')
            outfile.write(' ENDINCLINATION=%s' % (self.gds_format_string(quote_attrib(self.ENDINCLINATION).encode(ExternalEncoding), input_name='ENDINCLINATION'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='linktarget', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='linktarget'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.STARTINCLINATION is not None and 'STARTINCLINATION' not in already_processed:
            already_processed.add('STARTINCLINATION')
            showIndent(outfile, level)
            outfile.write('STARTINCLINATION="%s",\n' % (self.STARTINCLINATION,))
        if self.COLOR is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            showIndent(outfile, level)
            outfile.write('COLOR="%s",\n' % (self.COLOR,))
        if self.ENDARROW is not None and 'ENDARROW' not in already_processed:
            already_processed.add('ENDARROW')
            showIndent(outfile, level)
            outfile.write('ENDARROW="%s",\n' % (self.ENDARROW,))
        if self.DESTINATION is not None and 'DESTINATION' not in already_processed:
            already_processed.add('DESTINATION')
            showIndent(outfile, level)
            outfile.write('DESTINATION="%s",\n' % (self.DESTINATION,))
        if self.SOURCE is not None and 'SOURCE' not in already_processed:
            already_processed.add('SOURCE')
            showIndent(outfile, level)
            outfile.write('SOURCE="%s",\n' % (self.SOURCE,))
        if self.STARTARROW is not None and 'STARTARROW' not in already_processed:
            already_processed.add('STARTARROW')
            showIndent(outfile, level)
            outfile.write('STARTARROW="%s",\n' % (self.STARTARROW,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID="%s",\n' % (self.ID,))
        if self.ENDINCLINATION is not None and 'ENDINCLINATION' not in already_processed:
            already_processed.add('ENDINCLINATION')
            showIndent(outfile, level)
            outfile.write('ENDINCLINATION="%s",\n' % (self.ENDINCLINATION,))
    def exportLiteralChildren(self, outfile, level, name_):


        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)

        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('STARTINCLINATION', node)
        if value is not None and 'STARTINCLINATION' not in already_processed:
            already_processed.add('STARTINCLINATION')
            self.STARTINCLINATION = value

        value = find_attr_value_('COLOR', node)
        if value is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            self.COLOR = value
        value = find_attr_value_('ENDARROW', node)
        if value is not None and 'ENDARROW' not in already_processed:
            already_processed.add('ENDARROW')
            self.ENDARROW = value
        value = find_attr_value_('DESTINATION', node)
        if value is not None and 'DESTINATION' not in already_processed:
            already_processed.add('DESTINATION')
            self.DESTINATION = value

        value = find_attr_value_('SOURCE', node)
        if value is not None and 'SOURCE' not in already_processed:
            already_processed.add('SOURCE')
            self.SOURCE = value
        value = find_attr_value_('STARTARROW', node)
        if value is not None and 'STARTARROW' not in already_processed:
            already_processed.add('STARTARROW')
            self.STARTARROW = value

        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value
        value = find_attr_value_('ENDINCLINATION', node)
        if value is not None and 'ENDINCLINATION' not in already_processed:
            already_processed.add('ENDINCLINATION')
            self.ENDINCLINATION = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass

# end class linktarget


class cloud(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, COLOR=None):
        self.original_tagname_ = None
        self.COLOR = _cast(None, COLOR)

    def factory(*args_, **kwargs_):
        if cloud.subclass:
            return cloud.subclass(*args_, **kwargs_)
        else:
            return cloud(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_COLOR(self): return self.COLOR
    def set_COLOR(self, COLOR): self.COLOR = COLOR

















    def hasContent_(self):
        if (


        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cloud', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cloud')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cloud', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cloud'):
        if self.COLOR is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            outfile.write(' COLOR=%s' % (self.gds_format_string(quote_attrib(self.COLOR).encode(ExternalEncoding), input_name='COLOR'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='cloud', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cloud'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.COLOR is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            showIndent(outfile, level)
            outfile.write('COLOR="%s",\n' % (self.COLOR,))
    def exportLiteralChildren(self, outfile, level, name_):


        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)

        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):

        value = find_attr_value_('COLOR', node)
        if value is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            self.COLOR = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cloud


class edge(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, COLOR=None, WIDTH=None, STYLE=None):
        self.original_tagname_ = None
        self.COLOR = _cast(None, COLOR)
        self.WIDTH = _cast(None, WIDTH)
        self.STYLE = _cast(None, STYLE)

    def factory(*args_, **kwargs_):
        if edge.subclass:
            return edge.subclass(*args_, **kwargs_)
        else:
            return edge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_COLOR(self): return self.COLOR
    def set_COLOR(self, COLOR): self.COLOR = COLOR
    def get_WIDTH(self): return self.WIDTH
    def set_WIDTH(self, WIDTH): self.WIDTH = WIDTH
    def get_STYLE(self): return self.STYLE
    def set_STYLE(self, STYLE): self.STYLE = STYLE





















    def hasContent_(self):
        if (


        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='edge', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='edge')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='edge', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='edge'):
        if self.COLOR is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            outfile.write(' COLOR=%s' % (self.gds_format_string(quote_attrib(self.COLOR).encode(ExternalEncoding), input_name='COLOR'), ))
        if self.WIDTH is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            outfile.write(' WIDTH=%s' % (self.gds_format_string(quote_attrib(self.WIDTH).encode(ExternalEncoding), input_name='WIDTH'), ))
        if self.STYLE is not None and 'STYLE' not in already_processed:
            already_processed.add('STYLE')
            outfile.write(' STYLE=%s' % (self.gds_format_string(quote_attrib(self.STYLE).encode(ExternalEncoding), input_name='STYLE'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='edge', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='edge'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.COLOR is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            showIndent(outfile, level)
            outfile.write('COLOR="%s",\n' % (self.COLOR,))
        if self.WIDTH is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            showIndent(outfile, level)
            outfile.write('WIDTH="%s",\n' % (self.WIDTH,))
        if self.STYLE is not None and 'STYLE' not in already_processed:
            already_processed.add('STYLE')
            showIndent(outfile, level)
            outfile.write('STYLE="%s",\n' % (self.STYLE,))
    def exportLiteralChildren(self, outfile, level, name_):


        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)

        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):

        value = find_attr_value_('COLOR', node)
        if value is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            self.COLOR = value

        value = find_attr_value_('WIDTH', node)
        if value is not None and 'WIDTH' not in already_processed:
            already_processed.add('WIDTH')
            self.WIDTH = value

        value = find_attr_value_('STYLE', node)
        if value is not None and 'STYLE' not in already_processed:
            already_processed.add('STYLE')
            self.STYLE = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class edge


class font(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SIZE=None, BOLD=None, ITALIC=None, NAME=None):
        self.original_tagname_ = None
        self.SIZE = _cast(int, SIZE)
        self.BOLD = _cast(None, BOLD)
        self.ITALIC = _cast(None, ITALIC)
        self.NAME = _cast(None, NAME)

    def factory(*args_, **kwargs_):
        if font.subclass:
            return font.subclass(*args_, **kwargs_)
        else:
            return font(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SIZE(self): return self.SIZE
    def set_SIZE(self, SIZE): self.SIZE = SIZE
    def get_BOLD(self): return self.BOLD
    def set_BOLD(self, BOLD): self.BOLD = BOLD
    def get_ITALIC(self): return self.ITALIC
    def set_ITALIC(self, ITALIC): self.ITALIC = ITALIC
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME





















    def hasContent_(self):
        if (


        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='font', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='font')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='font', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='font'):
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.add('SIZE')
            outfile.write(' SIZE="%s"' % self.gds_format_integer(self.SIZE, input_name='SIZE'))
        if self.BOLD is not None and 'BOLD' not in already_processed:
            already_processed.add('BOLD')
            outfile.write(' BOLD=%s' % (self.gds_format_string(quote_attrib(self.BOLD).encode(ExternalEncoding), input_name='BOLD'), ))
        if self.ITALIC is not None and 'ITALIC' not in already_processed:
            already_processed.add('ITALIC')
            outfile.write(' ITALIC=%s' % (self.gds_format_string(quote_attrib(self.ITALIC).encode(ExternalEncoding), input_name='ITALIC'), ))
        if self.NAME is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            outfile.write(' NAME=%s' % (self.gds_format_string(quote_attrib(self.NAME).encode(ExternalEncoding), input_name='NAME'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='font', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='font'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.SIZE is not None and 'SIZE' not in already_processed:
            already_processed.add('SIZE')
            showIndent(outfile, level)
            outfile.write('SIZE=%d,\n' % (self.SIZE,))
        if self.BOLD is not None and 'BOLD' not in already_processed:
            already_processed.add('BOLD')
            showIndent(outfile, level)
            outfile.write('BOLD="%s",\n' % (self.BOLD,))
        if self.ITALIC is not None and 'ITALIC' not in already_processed:
            already_processed.add('ITALIC')
            showIndent(outfile, level)
            outfile.write('ITALIC="%s",\n' % (self.ITALIC,))
        if self.NAME is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            showIndent(outfile, level)
            outfile.write('NAME="%s",\n' % (self.NAME,))
    def exportLiteralChildren(self, outfile, level, name_):


        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)

        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):

        value = find_attr_value_('SIZE', node)
        if value is not None and 'SIZE' not in already_processed:
            already_processed.add('SIZE')
            try:
                self.SIZE = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)

        value = find_attr_value_('BOLD', node)
        if value is not None and 'BOLD' not in already_processed:
            already_processed.add('BOLD')
            self.BOLD = value
        value = find_attr_value_('ITALIC', node)
        if value is not None and 'ITALIC' not in already_processed:
            already_processed.add('ITALIC')
            self.ITALIC = value

        value = find_attr_value_('NAME', node)
        if value is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            self.NAME = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class font


class hook(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NAME=None, Parameters=None, text=None):
        self.original_tagname_ = None
        self.NAME = _cast(None, NAME)
        self.Parameters = Parameters
        self.text = text
    def factory(*args_, **kwargs_):
        if hook.subclass:
            return hook.subclass(*args_, **kwargs_)
        else:
            return hook(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Parameters(self): return self.Parameters
    def set_Parameters(self, Parameters): self.Parameters = Parameters
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME


















    def hasContent_(self):
        if (
            self.Parameters is not None or
            self.text is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='hook', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hook')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='hook', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='hook'):
        if self.NAME is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            outfile.write(' NAME=%s' % (self.gds_format_string(quote_attrib(self.NAME).encode(ExternalEncoding), input_name='NAME'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='hook', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Parameters is not None:
            self.Parameters.export(outfile, level, namespace_, name_='Parameters', pretty_print=pretty_print)
        if self.text is not None:
            self.text.export(outfile, level, namespace_, name_='text', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='hook'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.NAME is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            showIndent(outfile, level)
            outfile.write('NAME="%s",\n' % (self.NAME,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Parameters is not None:
            showIndent(outfile, level)
            outfile.write('Parameters=model_.Parameters(\n')
            self.Parameters.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.text is not None:
            showIndent(outfile, level)
            outfile.write('text=model_.text(\n')
            self.text.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):

        value = find_attr_value_('NAME', node)
        if value is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            self.NAME = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Parameters':
            obj_ = Parameters.factory()
            obj_.build(child_)
            self.Parameters = obj_
            obj_.original_tagname_ = 'Parameters'
        elif nodeName_ == 'text':
            obj_ = text.factory()
            obj_.build(child_)
            self.text = obj_
            obj_.original_tagname_ = 'text'
# end class hook


class icon(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BUILTIN=None):
        self.original_tagname_ = None
        self.BUILTIN = _cast(None, BUILTIN)

    def factory(*args_, **kwargs_):
        if icon.subclass:
            return icon.subclass(*args_, **kwargs_)
        else:
            return icon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BUILTIN(self): return self.BUILTIN
    def set_BUILTIN(self, BUILTIN): self.BUILTIN = BUILTIN


    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='icon', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='icon')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='icon', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='icon'):
        if self.BUILTIN is not None and 'BUILTIN' not in already_processed:
            already_processed.add('BUILTIN')
            outfile.write(' BUILTIN=%s' % (self.gds_format_string(quote_attrib(self.BUILTIN).encode(ExternalEncoding), input_name='BUILTIN'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='icon', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='icon'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.BUILTIN is not None and 'BUILTIN' not in already_processed:
            already_processed.add('BUILTIN')
            showIndent(outfile, level)
            outfile.write('BUILTIN="%s",\n' % (self.BUILTIN,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('BUILTIN', node)
        if value is not None and 'BUILTIN' not in already_processed:
            already_processed.add('BUILTIN')
            self.BUILTIN = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class icon


class attribute(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NAME=None, VALUE=None):
        self.original_tagname_ = None
        self.NAME = _cast(None, NAME)
        self.VALUE = _cast(None, VALUE)
    def factory(*args_, **kwargs_):
        if attribute.subclass:
            return attribute.subclass(*args_, **kwargs_)
        else:
            return attribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NAME(self): return self.NAME
    def set_NAME(self, NAME): self.NAME = NAME
    def get_VALUE(self): return self.VALUE
    def set_VALUE(self, VALUE): self.VALUE = VALUE
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='attribute', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='attribute', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='attribute'):
        if self.NAME is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            outfile.write(' NAME=%s' % (self.gds_format_string(quote_attrib(self.NAME).encode(ExternalEncoding), input_name='NAME'), ))
        if self.VALUE is not None and 'VALUE' not in already_processed:
            already_processed.add('VALUE')
            outfile.write(' VALUE=%s' % (self.gds_format_string(quote_attrib(self.VALUE).encode(ExternalEncoding), input_name='VALUE'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='attribute', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='attribute'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.NAME is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            showIndent(outfile, level)
            outfile.write('NAME="%s",\n' % (self.NAME,))
        if self.VALUE is not None and 'VALUE' not in already_processed:
            already_processed.add('VALUE')
            showIndent(outfile, level)
            outfile.write('VALUE="%s",\n' % (self.VALUE,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NAME', node)
        if value is not None and 'NAME' not in already_processed:
            already_processed.add('NAME')
            self.NAME = value
        value = find_attr_value_('VALUE', node)
        if value is not None and 'VALUE' not in already_processed:
            already_processed.add('VALUE')
            self.VALUE = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class attribute


class attribute_layout(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VALUE_WIDTH=None, NAME_WIDTH=None):
        self.original_tagname_ = None
        self.VALUE_WIDTH = _cast(int, VALUE_WIDTH)
        self.NAME_WIDTH = _cast(int, NAME_WIDTH)
    def factory(*args_, **kwargs_):
        if attribute_layout.subclass:
            return attribute_layout.subclass(*args_, **kwargs_)
        else:
            return attribute_layout(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VALUE_WIDTH(self): return self.VALUE_WIDTH
    def set_VALUE_WIDTH(self, VALUE_WIDTH): self.VALUE_WIDTH = VALUE_WIDTH
    def get_NAME_WIDTH(self): return self.NAME_WIDTH
    def set_NAME_WIDTH(self, NAME_WIDTH): self.NAME_WIDTH = NAME_WIDTH
    def hasContent_(self):
        if (


        ):
            return True
        else:
            return False

    def export(self, outfile, level, namespace_='', name_='attribute_layout', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute_layout')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='attribute_layout', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='attribute_layout'):
        if self.VALUE_WIDTH is not None and 'VALUE_WIDTH' not in already_processed:
            already_processed.add('VALUE_WIDTH')
            outfile.write(' VALUE_WIDTH="%s"' % self.gds_format_integer(self.VALUE_WIDTH, input_name='VALUE_WIDTH'))
        if self.NAME_WIDTH is not None and 'NAME_WIDTH' not in already_processed:
            already_processed.add('NAME_WIDTH')
            outfile.write(' NAME_WIDTH="%s"' % self.gds_format_integer(self.NAME_WIDTH, input_name='NAME_WIDTH'))
    def exportChildren(self, outfile, level, namespace_='', name_='attribute_layout', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='attribute_layout'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.VALUE_WIDTH is not None and 'VALUE_WIDTH' not in already_processed:
            already_processed.add('VALUE_WIDTH')
            showIndent(outfile, level)

            outfile.write('VALUE_WIDTH=%d,\n' % (self.VALUE_WIDTH,))
        if self.NAME_WIDTH is not None and 'NAME_WIDTH' not in already_processed:
            already_processed.add('NAME_WIDTH')
            showIndent(outfile, level)
            outfile.write('NAME_WIDTH=%d,\n' % (self.NAME_WIDTH,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('VALUE_WIDTH', node)
        if value is not None and 'VALUE_WIDTH' not in already_processed:
            already_processed.add('VALUE_WIDTH')
            try:
                self.VALUE_WIDTH = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('NAME_WIDTH', node)
        if value is not None and 'NAME_WIDTH' not in already_processed:
            already_processed.add('NAME_WIDTH')
            try:
                self.NAME_WIDTH = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class attribute_layout


class html(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if html.subclass:
            return html.subclass(*args_, **kwargs_)
        else:
            return html(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='html', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='html')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='html', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='html'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='html', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='html'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)

        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)

        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):




        pass

    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'html')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class html


class richcontent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TYPE=None, html=None):
        self.original_tagname_ = None
        self.TYPE = _cast(None, TYPE)
        self.html = html
    def factory(*args_, **kwargs_):
        if richcontent.subclass:
            return richcontent.subclass(*args_, **kwargs_)
        else:
            return richcontent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_html(self): return self.html
    def set_html(self, html): self.html = html
    def get_TYPE(self): return self.TYPE
    def set_TYPE(self, TYPE): self.TYPE = TYPE
    def hasContent_(self):
        if (
            self.html is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='richcontent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='richcontent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='richcontent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='richcontent'):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            outfile.write(' TYPE=%s' % (self.gds_format_string(quote_attrib(self.TYPE).encode(ExternalEncoding), input_name='TYPE'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='richcontent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.html is not None:
            self.html.export(outfile, level, namespace_, name_='html', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='richcontent'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TYPE is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            showIndent(outfile, level)
            outfile.write('TYPE="%s",\n' % (self.TYPE,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.html is not None:
            showIndent(outfile, level)
            outfile.write('html=model_.html(\n')
            self.html.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('TYPE', node)
        if value is not None and 'TYPE' not in already_processed:
            already_processed.add('TYPE')
            self.TYPE = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'html':
            obj_ = html.factory()
            obj_.build(child_)
            self.html = obj_
            obj_.original_tagname_ = 'html'
# end class richcontent


class map(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, node=None):
        self.original_tagname_ = None
        self.version = _cast(None, version)
        self.node = node
    def factory(*args_, **kwargs_):
        if map.subclass:
            return map.subclass(*args_, **kwargs_)
        else:
            return map(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_node(self): return self.node
    def set_node(self, node): self.node = node
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
















    def hasContent_(self):
        if (
            self.node is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='map', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='map')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='map', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='map'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='map', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.node is not None:
            self.node.export(outfile, level, namespace_, name_='node', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='map'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.node is not None:
            showIndent(outfile, level)
            outfile.write('node=model_.node(\n')
            self.node.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'node':
            obj_ = node.factory()
            obj_.build(child_)
            self.node = obj_
            obj_.original_tagname_ = 'node'
# end class map


class node(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, HGAP=None, STYLE=None, CREATED=None, COLOR=None, TEXT=None, FOLDED=None, MODIFIED=None, LINK=None, VSHIFT=None, POSITION=None, BACKGROUND_COLOR=None, ID=None, VGAP=None, ENCRYPTED_CONTENT=None, arrowlink=None, attribute=None, attribute_layout=None, linktarget=None, cloud=None, edge=None, font=None, hook=None, icon=None, node=None, richcontent=None):
        self.original_tagname_ = None
        self.HGAP = _cast(int, HGAP)
        self.STYLE = _cast(None, STYLE)
        self.CREATED = _cast(int, CREATED)
        self.COLOR = _cast(None, COLOR)
        self.TEXT = _cast(None, TEXT)
        self.FOLDED = _cast(None, FOLDED)
        self.MODIFIED = _cast(int, MODIFIED)
        self.LINK = _cast(None, LINK)
        self.VSHIFT = _cast(int, VSHIFT)
        self.POSITION = _cast(None, POSITION)
        self.BACKGROUND_COLOR = _cast(None, BACKGROUND_COLOR)
        self.ID = _cast(None, ID)
        self.VGAP = _cast(int, VGAP)
        self.ENCRYPTED_CONTENT = _cast(None, ENCRYPTED_CONTENT)
        if arrowlink is None:
            self.arrowlink = []
        else:
            self.arrowlink = arrowlink
        if attribute is None:
            self.attribute = []
        else:
            self.attribute = attribute
        if attribute_layout is None:
            self.attribute_layout = []
        else:
            self.attribute_layout = attribute_layout
        if linktarget is None:
            self.linktarget = []
        else:
            self.linktarget = linktarget
        if cloud is None:
            self.cloud = []
        else:
            self.cloud = cloud
        if edge is None:
            self.edge = []
        else:
            self.edge = edge
        if font is None:
            self.font = []
        else:
            self.font = font
        if hook is None:
            self.hook = []
        else:
            self.hook = hook
        if icon is None:
            self.icon = []
        else:
            self.icon = icon
        if node is None:
            self.node = []
        else:
            self.node = node
        if richcontent is None:
            self.richcontent = []
        else:
            self.richcontent = richcontent
    def factory(*args_, **kwargs_):
        if node.subclass:
            return node.subclass(*args_, **kwargs_)
        else:
            return node(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_arrowlink(self): return self.arrowlink
    def set_arrowlink(self, arrowlink): self.arrowlink = arrowlink
    def add_arrowlink(self, value): self.arrowlink.append(value)
    def insert_arrowlink(self, index, value): self.arrowlink[index] = value
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def add_attribute(self, value): self.attribute.append(value)
    def insert_attribute(self, index, value): self.attribute[index] = value
    def get_attribute_layout(self): return self.attribute_layout
    def set_attribute_layout(self, attribute_layout): self.attribute_layout = attribute_layout
    def add_attribute_layout(self, value): self.attribute_layout.append(value)
    def insert_attribute_layout(self, index, value): self.attribute_layout[index] = value
    def get_linktarget(self): return self.linktarget
    def set_linktarget(self, linktarget): self.linktarget = linktarget
    def add_linktarget(self, value): self.linktarget.append(value)
    def insert_linktarget(self, index, value): self.linktarget[index] = value
    def get_cloud(self): return self.cloud
    def set_cloud(self, cloud): self.cloud = cloud
    def add_cloud(self, value): self.cloud.append(value)
    def insert_cloud(self, index, value): self.cloud[index] = value
    def get_edge(self): return self.edge
    def set_edge(self, edge): self.edge = edge
    def add_edge(self, value): self.edge.append(value)
    def insert_edge(self, index, value): self.edge[index] = value
    def get_font(self): return self.font
    def set_font(self, font): self.font = font
    def add_font(self, value): self.font.append(value)
    def insert_font(self, index, value): self.font[index] = value
    def get_hook(self): return self.hook
    def set_hook(self, hook): self.hook = hook
    def add_hook(self, value): self.hook.append(value)
    def insert_hook(self, index, value): self.hook[index] = value
    def get_icon(self): return self.icon
    def set_icon(self, icon): self.icon = icon
    def add_icon(self, value): self.icon.append(value)
    def insert_icon(self, index, value): self.icon[index] = value
    def get_node(self): return self.node
    def set_node(self, node): self.node = node
    def add_node(self, value): self.node.append(value)
    def insert_node(self, index, value): self.node[index] = value
    def get_richcontent(self): return self.richcontent
    def set_richcontent(self, richcontent): self.richcontent = richcontent
    def add_richcontent(self, value): self.richcontent.append(value)
    def insert_richcontent(self, index, value): self.richcontent[index] = value
    def get_HGAP(self): return self.HGAP
    def set_HGAP(self, HGAP): self.HGAP = HGAP
    def get_STYLE(self): return self.STYLE
    def set_STYLE(self, STYLE): self.STYLE = STYLE
    def get_CREATED(self): return self.CREATED
    def set_CREATED(self, CREATED): self.CREATED = CREATED
    def get_COLOR(self): return self.COLOR
    def set_COLOR(self, COLOR): self.COLOR = COLOR
    def get_TEXT(self): return self.TEXT
    def set_TEXT(self, TEXT): self.TEXT = TEXT
    def get_FOLDED(self): return self.FOLDED
    def set_FOLDED(self, FOLDED): self.FOLDED = FOLDED
    def get_MODIFIED(self): return self.MODIFIED
    def set_MODIFIED(self, MODIFIED): self.MODIFIED = MODIFIED
    def get_LINK(self): return self.LINK
    def set_LINK(self, LINK): self.LINK = LINK
    def get_VSHIFT(self): return self.VSHIFT
    def set_VSHIFT(self, VSHIFT): self.VSHIFT = VSHIFT
    def get_POSITION(self): return self.POSITION
    def set_POSITION(self, POSITION): self.POSITION = POSITION
    def get_BACKGROUND_COLOR(self): return self.BACKGROUND_COLOR
    def set_BACKGROUND_COLOR(self, BACKGROUND_COLOR): self.BACKGROUND_COLOR = BACKGROUND_COLOR
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_VGAP(self): return self.VGAP
    def set_VGAP(self, VGAP): self.VGAP = VGAP
    def get_ENCRYPTED_CONTENT(self): return self.ENCRYPTED_CONTENT
    def set_ENCRYPTED_CONTENT(self, ENCRYPTED_CONTENT): self.ENCRYPTED_CONTENT = ENCRYPTED_CONTENT






















































    def hasContent_(self):
        if (
            self.arrowlink or
            self.attribute or
            self.attribute_layout or
            self.linktarget or
            self.cloud or
            self.edge or
            self.font or
            self.hook or
            self.icon or
            self.node or
            self.richcontent
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='node', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='node')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='node', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='node'):
        if self.HGAP is not None and 'HGAP' not in already_processed:
            already_processed.add('HGAP')
            outfile.write(' HGAP="%s"' % self.gds_format_integer(self.HGAP, input_name='HGAP'))
        if self.STYLE is not None and 'STYLE' not in already_processed:
            already_processed.add('STYLE')
            outfile.write(' STYLE=%s' % (self.gds_format_string(quote_attrib(self.STYLE).encode(ExternalEncoding), input_name='STYLE'), ))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            outfile.write(' CREATED="%s"' % self.gds_format_integer(self.CREATED, input_name='CREATED'))
        if self.COLOR is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            outfile.write(' COLOR=%s' % (self.gds_format_string(quote_attrib(self.COLOR).encode(ExternalEncoding), input_name='COLOR'), ))
        if self.TEXT is not None and 'TEXT' not in already_processed:
            already_processed.add('TEXT')
            outfile.write(' TEXT=%s' % (self.gds_format_string(quote_attrib(self.TEXT).encode(ExternalEncoding), input_name='TEXT'), ))
        if self.FOLDED is not None and 'FOLDED' not in already_processed:
            already_processed.add('FOLDED')
            outfile.write(' FOLDED=%s' % (self.gds_format_string(quote_attrib(self.FOLDED).encode(ExternalEncoding), input_name='FOLDED'), ))
        if self.MODIFIED is not None and 'MODIFIED' not in already_processed:
            already_processed.add('MODIFIED')
            outfile.write(' MODIFIED="%s"' % self.gds_format_integer(self.MODIFIED, input_name='MODIFIED'))
        if self.LINK is not None and 'LINK' not in already_processed:
            already_processed.add('LINK')
            outfile.write(' LINK=%s' % (self.gds_format_string(quote_attrib(self.LINK).encode(ExternalEncoding), input_name='LINK'), ))
        if self.VSHIFT is not None and 'VSHIFT' not in already_processed:
            already_processed.add('VSHIFT')
            outfile.write(' VSHIFT="%s"' % self.gds_format_integer(self.VSHIFT, input_name='VSHIFT'))
        if self.POSITION is not None and 'POSITION' not in already_processed:
            already_processed.add('POSITION')
            outfile.write(' POSITION=%s' % (self.gds_format_string(quote_attrib(self.POSITION).encode(ExternalEncoding), input_name='POSITION'), ))
        if self.BACKGROUND_COLOR is not None and 'BACKGROUND_COLOR' not in already_processed:
            already_processed.add('BACKGROUND_COLOR')
            outfile.write(' BACKGROUND_COLOR=%s' % (self.gds_format_string(quote_attrib(self.BACKGROUND_COLOR).encode(ExternalEncoding), input_name='BACKGROUND_COLOR'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.VGAP is not None and 'VGAP' not in already_processed:
            already_processed.add('VGAP')
            outfile.write(' VGAP="%s"' % self.gds_format_integer(self.VGAP, input_name='VGAP'))
        if self.ENCRYPTED_CONTENT is not None and 'ENCRYPTED_CONTENT' not in already_processed:
            already_processed.add('ENCRYPTED_CONTENT')
            outfile.write(' ENCRYPTED_CONTENT=%s' % (self.gds_format_string(quote_attrib(self.ENCRYPTED_CONTENT).encode(ExternalEncoding), input_name='ENCRYPTED_CONTENT'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='node', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for arrowlink_ in self.arrowlink:
            arrowlink_.export(outfile, level, namespace_, name_='arrowlink', pretty_print=pretty_print)
        for attribute_ in self.attribute:
            attribute_.export(outfile, level, namespace_, name_='attribute', pretty_print=pretty_print)
        for attribute_layout_ in self.attribute_layout:
            attribute_layout_.export(outfile, level, namespace_, name_='attribute_layout', pretty_print=pretty_print)
        for linktarget_ in self.linktarget:
            linktarget_.export(outfile, level, namespace_, name_='linktarget', pretty_print=pretty_print)
        for cloud_ in self.cloud:
            cloud_.export(outfile, level, namespace_, name_='cloud', pretty_print=pretty_print)
        for edge_ in self.edge:
            edge_.export(outfile, level, namespace_, name_='edge', pretty_print=pretty_print)
        for font_ in self.font:
            font_.export(outfile, level, namespace_, name_='font', pretty_print=pretty_print)
        for hook_ in self.hook:
            hook_.export(outfile, level, namespace_, name_='hook', pretty_print=pretty_print)
        for icon_ in self.icon:
            icon_.export(outfile, level, namespace_, name_='icon', pretty_print=pretty_print)
        for node_ in self.node:
            node_.export(outfile, level, namespace_, name_='node', pretty_print=pretty_print)
        for richcontent_ in self.richcontent:
            richcontent_.export(outfile, level, namespace_, name_='richcontent', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='node'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.HGAP is not None and 'HGAP' not in already_processed:
            already_processed.add('HGAP')
            showIndent(outfile, level)
            outfile.write('HGAP=%d,\n' % (self.HGAP,))
        if self.STYLE is not None and 'STYLE' not in already_processed:
            already_processed.add('STYLE')
            showIndent(outfile, level)
            outfile.write('STYLE="%s",\n' % (self.STYLE,))
        if self.CREATED is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            showIndent(outfile, level)
            outfile.write('CREATED=%d,\n' % (self.CREATED,))
        if self.COLOR is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            showIndent(outfile, level)
            outfile.write('COLOR="%s",\n' % (self.COLOR,))
        if self.TEXT is not None and 'TEXT' not in already_processed:
            already_processed.add('TEXT')
            showIndent(outfile, level)
            outfile.write('TEXT="%s",\n' % (self.TEXT,))
        if self.FOLDED is not None and 'FOLDED' not in already_processed:
            already_processed.add('FOLDED')
            showIndent(outfile, level)
            outfile.write('FOLDED="%s",\n' % (self.FOLDED,))
        if self.MODIFIED is not None and 'MODIFIED' not in already_processed:
            already_processed.add('MODIFIED')
            showIndent(outfile, level)
            outfile.write('MODIFIED=%d,\n' % (self.MODIFIED,))
        if self.LINK is not None and 'LINK' not in already_processed:
            already_processed.add('LINK')
            showIndent(outfile, level)
            outfile.write('LINK="%s",\n' % (self.LINK,))
        if self.VSHIFT is not None and 'VSHIFT' not in already_processed:
            already_processed.add('VSHIFT')
            showIndent(outfile, level)
            outfile.write('VSHIFT=%d,\n' % (self.VSHIFT,))
        if self.POSITION is not None and 'POSITION' not in already_processed:
            already_processed.add('POSITION')
            showIndent(outfile, level)
            outfile.write('POSITION="%s",\n' % (self.POSITION,))
        if self.BACKGROUND_COLOR is not None and 'BACKGROUND_COLOR' not in already_processed:
            already_processed.add('BACKGROUND_COLOR')
            showIndent(outfile, level)
            outfile.write('BACKGROUND_COLOR="%s",\n' % (self.BACKGROUND_COLOR,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            showIndent(outfile, level)
            outfile.write('ID="%s",\n' % (self.ID,))
        if self.VGAP is not None and 'VGAP' not in already_processed:
            already_processed.add('VGAP')
            showIndent(outfile, level)
            outfile.write('VGAP=%d,\n' % (self.VGAP,))
        if self.ENCRYPTED_CONTENT is not None and 'ENCRYPTED_CONTENT' not in already_processed:
            already_processed.add('ENCRYPTED_CONTENT')
            showIndent(outfile, level)
            outfile.write('ENCRYPTED_CONTENT="%s",\n' % (self.ENCRYPTED_CONTENT,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('arrowlink=[\n')
        level += 1
        for arrowlink_ in self.arrowlink:
            showIndent(outfile, level)
            outfile.write('model_.arrowlink(\n')
            arrowlink_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attribute=[\n')
        level += 1
        for attribute_ in self.attribute:
            showIndent(outfile, level)
            outfile.write('model_.attribute(\n')
            attribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('attribute_layout=[\n')
        level += 1
        for attribute_layout_ in self.attribute_layout:
            showIndent(outfile, level)
            outfile.write('model_.attribute_layout(\n')
            attribute_layout_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('linktarget=[\n')
        level += 1
        for linktarget_ in self.linktarget:
            showIndent(outfile, level)
            outfile.write('model_.linktarget(\n')
            linktarget_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cloud=[\n')
        level += 1
        for cloud_ in self.cloud:
            showIndent(outfile, level)
            outfile.write('model_.cloud(\n')
            cloud_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('edge=[\n')
        level += 1
        for edge_ in self.edge:
            showIndent(outfile, level)
            outfile.write('model_.edge(\n')
            edge_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('font=[\n')
        level += 1
        for font_ in self.font:
            showIndent(outfile, level)
            outfile.write('model_.font(\n')
            font_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('hook=[\n')
        level += 1
        for hook_ in self.hook:
            showIndent(outfile, level)
            outfile.write('model_.hook(\n')
            hook_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('icon=[\n')
        level += 1
        for icon_ in self.icon:
            showIndent(outfile, level)
            outfile.write('model_.icon(\n')
            icon_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('node=[\n')
        level += 1
        for node_ in self.node:
            showIndent(outfile, level)
            outfile.write('model_.node(\n')
            node_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('richcontent=[\n')
        level += 1
        for richcontent_ in self.richcontent:
            showIndent(outfile, level)
            outfile.write('model_.richcontent(\n')
            richcontent_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):

        value = find_attr_value_('HGAP', node)
        if value is not None and 'HGAP' not in already_processed:
            already_processed.add('HGAP')
            try:
                self.HGAP = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)

        value = find_attr_value_('STYLE', node)
        if value is not None and 'STYLE' not in already_processed:
            already_processed.add('STYLE')
            self.STYLE = value
        value = find_attr_value_('CREATED', node)
        if value is not None and 'CREATED' not in already_processed:
            already_processed.add('CREATED')
            try:
                self.CREATED = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)

        value = find_attr_value_('COLOR', node)
        if value is not None and 'COLOR' not in already_processed:
            already_processed.add('COLOR')
            self.COLOR = value

        value = find_attr_value_('TEXT', node)
        if value is not None and 'TEXT' not in already_processed:
            already_processed.add('TEXT')
            self.TEXT = value
        value = find_attr_value_('FOLDED', node)
        if value is not None and 'FOLDED' not in already_processed:
            already_processed.add('FOLDED')
            self.FOLDED = value
        value = find_attr_value_('MODIFIED', node)
        if value is not None and 'MODIFIED' not in already_processed:
            already_processed.add('MODIFIED')
            try:
                self.MODIFIED = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)

        value = find_attr_value_('LINK', node)
        if value is not None and 'LINK' not in already_processed:
            already_processed.add('LINK')
            self.LINK = value
        value = find_attr_value_('VSHIFT', node)
        if value is not None and 'VSHIFT' not in already_processed:
            already_processed.add('VSHIFT')
            try:
                self.VSHIFT = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('POSITION', node)
        if value is not None and 'POSITION' not in already_processed:
            already_processed.add('POSITION')
            self.POSITION = value
        value = find_attr_value_('BACKGROUND_COLOR', node)
        if value is not None and 'BACKGROUND_COLOR' not in already_processed:
            already_processed.add('BACKGROUND_COLOR')
            self.BACKGROUND_COLOR = value

        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.add('ID')
            self.ID = value

        value = find_attr_value_('VGAP', node)
        if value is not None and 'VGAP' not in already_processed:
            already_processed.add('VGAP')
            try:
                self.VGAP = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('ENCRYPTED_CONTENT', node)
        if value is not None and 'ENCRYPTED_CONTENT' not in already_processed:
            already_processed.add('ENCRYPTED_CONTENT')
            self.ENCRYPTED_CONTENT = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'arrowlink':
            obj_ = arrowlink.factory()
            obj_.build(child_)
            self.arrowlink.append(obj_)
            obj_.original_tagname_ = 'arrowlink'
        elif nodeName_ == 'attribute':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.attribute.append(obj_)
            obj_.original_tagname_ = 'attribute'
        elif nodeName_ == 'attribute_layout':
            obj_ = attribute_layout.factory()
            obj_.build(child_)
            self.attribute_layout.append(obj_)
            obj_.original_tagname_ = 'attribute_layout'
        elif nodeName_ == 'linktarget':
            obj_ = linktarget.factory()
            obj_.build(child_)
            self.linktarget.append(obj_)
            obj_.original_tagname_ = 'linktarget'
        elif nodeName_ == 'cloud':
            obj_ = cloud.factory()
            obj_.build(child_)
            self.cloud.append(obj_)
            obj_.original_tagname_ = 'cloud'
        elif nodeName_ == 'edge':
            obj_ = edge.factory()
            obj_.build(child_)
            self.edge.append(obj_)
            obj_.original_tagname_ = 'edge'
        elif nodeName_ == 'font':
            obj_ = font.factory()
            obj_.build(child_)
            self.font.append(obj_)
            obj_.original_tagname_ = 'font'
        elif nodeName_ == 'hook':
            obj_ = hook.factory()
            obj_.build(child_)
            self.hook.append(obj_)
            obj_.original_tagname_ = 'hook'
        elif nodeName_ == 'icon':
            obj_ = icon.factory()
            obj_.build(child_)
            self.icon.append(obj_)
            obj_.original_tagname_ = 'icon'
        elif nodeName_ == 'node':
            obj_ = node.factory()
            obj_.build(child_)
            self.node.append(obj_)
            obj_.original_tagname_ = 'node'
        elif nodeName_ == 'richcontent':
            obj_ = richcontent.factory()
            obj_.build(child_)
            self.richcontent.append(obj_)
            obj_.original_tagname_ = 'richcontent'
# end class node


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Parameters'
        rootClass = Parameters
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')

        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Parameters'
        rootClass = Parameters
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Parameters'
        rootClass = Parameters
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')

        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Parameters'
        rootClass = Parameters
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from freemindSchema import *\n\n')
        sys.stdout.write('import freemindSchema as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Parameters",
    "arrowlink",
    "attribute",
    "attribute_layout",
    "cloud",
    "edge",
    "font",
    "hook",
    "html",
    "icon",
    "linktarget",
    "map",
    "node",
    "richcontent",
    "text"
]
